---
description: React hooks guide – useState, useEffect, useContext, useReducer, useMemo, useCallback, custom hooks, useRef. Use when working with React hooks.
globs: "**/*.tsx, **/*.jsx"
alwaysApply: false
priority: 40
---

# React Hooks Guide

Use this rule together with `react-components.mdc` and `react-state.mdc` for full React coverage. This file covers all React hooks.

## Hooks

### useState

```typescript
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(prev => prev - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

// Complex state
function Form() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0,
  });

  const updateField = (field: string, value: string | number) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <form>
      <input
        value={formData.name}
        onChange={(e) => updateField('name', e.target.value)}
      />
      <input
        type="email"
        value={formData.email}
        onChange={(e) => updateField('email', e.target.value)}
      />
      <input
        type="number"
        value={formData.age}
        onChange={(e) => updateField('age', parseInt(e.target.value))}
      />
    </form>
  );
}
```

### useEffect

```typescript
import { useEffect, useState } from 'react';

// Basic effect
function DataFetcher({ userId }: { userId: string }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchData() {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setData(userData);
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [userId]); // Re-run when userId changes

  if (loading) return <div>Loading...</div>;
  return <div>{JSON.stringify(data)}</div>;
}

// Cleanup effect
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);

    // Cleanup function
    return () => clearInterval(interval);
  }, []); // Empty deps = run once on mount, cleanup on unmount

  return <div>Seconds: {seconds}</div>;
}

// Conditional effect
function WindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return <div>Window: {windowSize.width} x {windowSize.height}</div>;
}
```

### useContext

```typescript
import { createContext, useContext, useState, ReactNode } from 'react';

interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  const toggleTheme = () => setTheme(prev => prev === 'light' ? 'dark' : 'light');
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) throw new Error('useTheme must be used within ThemeProvider');
  return context;
}
```

### useReducer

```typescript
import { useReducer } from 'react';

interface CounterState { count: number; history: number[]; }
type CounterAction =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset' }
  | { type: 'set'; payload: number };

function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1, history: [...state.history, state.count + 1] };
    case 'decrement':
      return { count: state.count - 1, history: [...state.history, state.count - 1] };
    case 'reset':
      return { count: 0, history: [] };
    case 'set':
      return { count: action.payload, history: [...state.history, action.payload] };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0, history: [] });
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'set', payload: 10 })}>Set to 10</button>
    </div>
  );
}
```

### useMemo & useCallback

```typescript
import { useMemo, useCallback, useState } from 'react';

// useMemo: Memoize expensive calculations
function ExpensiveComponent({ items }: { items: number[] }) {
  const expensiveValue = useMemo(() =>
    items.reduce((sum, item) => sum + item * item, 0), [items]);
  return <div>Result: {expensiveValue}</div>;
}

// useCallback: Memoize functions for stable references
function ParentComponent() {
  const [count, setCount] = useState(0);
  const handleClick = useCallback(() => {}, []);
  return <ChildComponent onClick={handleClick} />;
}
```

### Custom Hooks

```typescript
function useFetch<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let cancelled = false;
    async function fetchData() {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const json = await response.json();
        if (!cancelled) setData(json);
      } catch (err) {
        if (!cancelled) setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        if (!cancelled) setLoading(false);
      }
    }
    fetchData();
    return () => { cancelled = true; };
  }, [url]);

  return { data, loading, error };
}
```

### useRef

```typescript
import { useRef, useEffect } from 'react';

// DOM ref
function TextInputWithFocus() {
  const inputRef = useRef<HTMLInputElement>(null);
  useEffect(() => { inputRef.current?.focus(); }, []);
  return <input ref={inputRef} type="text" />;
}

// Mutable value without re-render
function Timer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const start = () => {
    if (intervalRef.current) return;
    intervalRef.current = setInterval(() => setCount(prev => prev + 1), 1000);
  };
  const stop = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };
  return <div><p>{count}</p><button onClick={start}>Start</button><button onClick={stop}>Stop</button></div>;
}
```

## See also

- `react-components.mdc` – Components, composition, conditional rendering, lists, best practices
- `react-state.mdc` – State management patterns, events, forms, performance, error boundaries, testing
